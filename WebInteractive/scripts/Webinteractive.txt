import subprocess
from flask import Flask, render_template, request, flash, redirect, url_for, session, send_from_directory
from flask_socketio import SocketIO, emit
import os
import threading

app = Flask(__name__,
            static_folder=os.path.abspath(os.path.join(os.path.dirname(__file__), 'static')),
            template_folder=os.path.abspath(os.path.join(os.path.dirname(__file__), 'templates')))
app.secret_key = 'super_secret_key_for_sessions'  # Change for production
socketio = SocketIO(app)

# Store running processes per session ID
running_processes = {}

# Store input for the script and an Event to signal its readiness
script_input_buffer = {} # {sid: str}
script_input_ready_event = {} # {sid: threading.Event}

def stream_script_output(sid, process):
    """Read stdout from the process, detect input requests, and emit to the client."""
    buffer = ""
    input_token = "SCRIPT_INPUT_REQUIRED"
    try:
        for char in iter(lambda: process.stdout.read(1), ''):
            # Emit each character as it is received
            print(f"[{sid}] RCV: '{char.strip()}'") # Debug print
            socketio.emit('script_output', {'data': char}, to=sid)
            
            buffer += char
            print(f"[{sid}] BUFFER: '{buffer.strip()}'") # Debug print
            # Check for the input request token within the buffer
            if input_token in buffer:
                print(f"[{sid}] TOKEN DETECTED!") # Debug print
                # If token is found, consume it from buffer for future checks
                output_before_token = buffer.split(input_token)[0]
                if output_before_token:
                    print(f"[{sid}] EMITTING PRE-TOKEN: '{output_before_token.strip()}'") # Debug print
                    socketio.emit('script_output', {'data': output_before_token}, to=sid)
                
                buffer = buffer.split(input_token, 1)[1] # Keep anything after the first token
                print(f"[{sid}] BUFFER AFTER TOKEN: '{buffer.strip()}'") # Debug print

                # Signal the client that input is requested
                print(f"[{sid}] EMITTING script_input_request") # Debug print
                socketio.emit('script_input_request', {'data': 'Input required'}, to=sid)
                
                # Wait for input from the client
                script_input_ready_event[sid].clear() # Clear the event before waiting
                print(f"[{sid}] WAITING FOR INPUT...") # Debug print
                script_input_ready_event[sid].wait()  # Block until input is ready
                print(f"[{sid}] INPUT RECEIVED!") # Debug print
                
                # Retrieve input, write to script's stdin, and clear
                input_data = script_input_buffer[sid]
                print(f"[{sid}] SENDING TO STDIN: '{input_data.strip()}'") # Debug print
                process.stdin.write(input_data)
                process.stdin.flush()
                
                script_input_buffer[sid] = None # Clear buffer after sending
                # Reset buffer after processing input request
                buffer = "" 
                
        # After loop, if there's anything left in the buffer, emit it (unlikely with char-by-char emit)
        if buffer:
            print(f"[{sid}] FINAL BUFFER EMIT: '{buffer.strip()}'") # Debug print
            socketio.emit('script_output', {'data': buffer}, to=sid)

        # Wait for the process to terminate and get the exit code
        process.wait()
        print(f"[{sid}] SCRIPT FINISHED. Exit Code: {process.returncode}") # Debug print
        
        # Emit a final message when the process finishes
        socketio.emit('script_finished', {'data': f'\n--- Script Finished (Exit Code: {process.returncode}) ---'}, to=sid)
    except Exception as e:
        print(f"Exception in stream_script_output for SID {sid}: {e}")
    finally:
        # Clean up session resources on disconnect or script finish
        # This will be handled in disconnect, remove from here to avoid double deletion
        pass

@app.route('/', methods=['GET', 'POST'])
def login():
    session.clear() # Clear any previous session data
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        if not username.lower().startswith('abc\\'):
            flash('Username must start with "abc\\".', 'error')
            return render_template('index.html')
            
        user_part = username.split('\\', 1)[1]
        session['username'] = user_part # Store username in session
        
        scripts_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'scripts'))
        sec_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'sec'))

        script_path = os.path.join(scripts_dir, 'save-credentials.ps1')
        file_path = os.path.join(sec_dir, f'abc_{user_part}.xml')
        
        try:
            command = [
                'powershell.exe', '-ExecutionPolicy', 'Bypass', '-File', script_path,
                '-username', user_part, '-password', password, '-FilePath', file_path
            ]
            subprocess.run(command, check=True, capture_output=True, text=True)
            flash(f'Credentials for {username} saved successfully!', 'success')
            return redirect(url_for('main'))
        except subprocess.CalledProcessError as e:
            print(f"Error executing PowerShell script: {e}\nStdout: {e.stdout}\nStderr: {e.stderr}")
            flash('Failed to save credentials.', 'error')
            return redirect(url_for('login'))

    return render_template('index.html')

@app.route('/main')
def main():
    if 'username' not in session:
        return redirect(url_for('login'))

    user_part = session['username']
    
    # Load script list
    scripts_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'scripts'))
    scripts = []
    if os.path.exists(scripts_dir):
        scripts = [f for f in os.listdir(scripts_dir) if f.endswith('.ps1') and f != 'save-credentials.ps1']

    # Load server list content
    server_list_content = ""
    server_list_file = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), 'input')), f'abc_{user_part}_serverlist.txt')
    if os.path.exists(server_list_file):
        with open(server_list_file, 'r') as f:
            server_list_content = f.read()

    return render_template('main.html', scripts=scripts, server_list_content=server_list_content)

@app.route('/save_credential/<string:cred_type>', methods=['POST'])
def save_credential(cred_type):
    if 'username' not in session:
        return redirect(url_for('login'))
        
    password = request.form.get('password')
    if not password:
        flash('Password cannot be empty.', 'error')
        return redirect(url_for('main'))

    user_part = session['username']
    script_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'scripts', 'save-credentials.ps1'))
    
    if cred_type == 'cvm':
        script_user = "Admin"
        display_name = "PE Admin"
    elif cred_type == 'ntnx':
        script_user = "nutanix"
        display_name = "Nutanix SSH"
    else:
        flash('Invalid credential type.', 'error')
        return redirect(url_for('main'))

    sec_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'sec'))
    file_path = os.path.join(sec_dir, f'abc_{user_part}_{cred_type}.xml')

    try:
        command = [
            'powershell.exe', '-ExecutionPolicy', 'Bypass', '-File', script_path,
            '-username', script_user, '-password', password, '-FilePath', file_path
        ]
        subprocess.run(command, check=True, capture_output=True, text=True)
        flash(f'{display_name} password saved successfully.', 'success')
    except subprocess.CalledProcessError as e:
        print(f"Error executing PowerShell script: {e}\nStdout: {e.stdout}\nStderr: {e.stderr}")
        flash(f'Failed to save {display_name} password.', 'error')
        
    return redirect(url_for('main'))

@app.route('/save_server_list', methods=['POST'])
def save_server_list():
    if 'username' not in session:
        return redirect(url_for('login'))

    server_list = request.form.get('Server_List')
    user_part = session['username']
    
    input_folder = os.path.abspath(os.path.join(os.path.dirname(__file__), 'input'))
    if not os.path.exists(input_folder):
        os.makedirs(input_folder)
        
    file_path = os.path.join(input_folder, f'abc_{user_part}_serverlist.txt')
    
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
        with open(file_path, 'w') as f:
            f.write(server_list)
        flash('Server list saved successfully.', 'success')
    except IOError as e:
        print(f"Error writing server list file: {e}")
        flash('Failed to save server list.', 'error')
        
    return redirect(url_for('main'))

@socketio.on('execute_script')
def execute_script(message):
    if 'username' not in session:
        return  # Or emit an error

    user_part = session['username']
    selected_script = message['script_name']
    
    scripts_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'scripts'))
    input_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'input'))
    sec_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'sec'))

    script_path = os.path.join(scripts_dir, selected_script)
    helper_script_path = os.path.join(scripts_dir, 'prompt-helper.ps1')

    if not os.path.normpath(script_path).startswith(scripts_dir) or not os.path.exists(script_path):
        emit('script_output', {'data': 'Error: Invalid or non-existent script selection.'})
        return

    try:
        params = []
        target_file = os.path.join(input_dir, f'abc_{user_part}_serverlist.txt')
        target_content = ""
        if os.path.exists(target_file):
            with open(target_file, 'r') as f:
                target_content = f.read()
        escaped_target_content = target_content.replace("'", "''")
        params.append(f"-target '{escaped_target_content}'")

        cred_file = os.path.join(sec_dir, f'abc_{user_part}.xml')
        if os.path.exists(cred_file):
            params.append(f"-credentials '{cred_file}'")

        peadmin_file = os.path.join(sec_dir, f'abc_{user_part}_cvm.xml')
        if os.path.exists(peadmin_file):
            params.append(f"-peadmin '{peadmin_file}'")

        nutanix_file = os.path.join(sec_dir, f'abc_{user_part}_ntnx.xml')
        if os.path.exists(nutanix_file):
            params.append(f"-nutanix '{nutanix_file}'")
        
        param_string = " ".join(params)
        
        # New command: Dot-source the helper, then call the main script
        ps_command = f". '{helper_script_path}'; & '{script_path}' {param_string}"

        command = ['powershell.exe', '-ExecutionPolicy', 'Bypass', '-Command', ps_command]
            
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=0,
            universal_newlines=True,
            cwd=scripts_dir
        )
        
        running_processes[request.sid] = process
        script_input_buffer[request.sid] = None # No input ready initially
        script_input_ready_event[request.sid] = threading.Event() # Create a new event for this session
        thread = threading.Thread(target=stream_script_output, args=(request.sid, process))
        thread.start()

    except Exception as e:
        emit('script_output', {'data': f"An unexpected error occurred: {e}"})

@socketio.on('input_to_script')
def input_to_script(message):
    """Forward client input to the running script's stdin."""
    process = running_processes.get(request.sid)
    if process:
        try:
            script_input_buffer[request.sid] = message['data'] + '\n'
            script_input_ready_event[request.sid].set() # Signal that input is ready
        except Exception as e:
            emit('script_output', {'data': f"\nError handling client input: {e}\n"})

@socketio.on('disconnect')
def disconnect(sid):
    """Clean up the process when the client disconnects."""
    process = running_processes.get(request.sid)
    if process:
        try:
            process.terminate() # Terminate the running script
        except Exception as e:
            print(f"Error terminating process on disconnect: {e}")
        finally:
            # Clean up all session-related resources
            if sid in running_processes:
                del running_processes[sid]
            if sid in script_input_buffer:
                del script_input_buffer[sid]
            if sid in script_input_ready_event:
                del script_input_ready_event[sid]
    print('Client disconnected')

@app.route('/output/', defaults={'subpath': ''})
@app.route('/output/<path:subpath>')
def output_files(subpath):
    if 'username' not in session:
        return redirect(url_for('login'))

    output_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'Output'))
    
    # Security: Ensure the requested path is within the output directory
    requested_path = os.path.abspath(os.path.join(output_dir, subpath))
    if not requested_path.startswith(output_dir):
        return "Access denied", 403

    if not os.path.exists(requested_path) or not os.path.isdir(requested_path):
        return "Not Found", 404

    dirs = []
    files = []
    for item in os.listdir(requested_path):
        item_path = os.path.join(requested_path, item)
        if os.path.isdir(item_path):
            dirs.append(item)
        else:
            files.append(item)

    return render_template('output.html', dirs=dirs, files=files, current_path=subpath)

@app.route('/download/<path:filepath>')
def download_file(filepath):
    if 'username' not in session:
        return redirect(url_for('login'))

    output_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'Output'))
    
    # Security: Ensure the requested file is within the output directory
    requested_path = os.path.abspath(os.path.join(output_dir, filepath))
    if not requested_path.startswith(output_dir):
        return "Access denied", 403

    if not os.path.exists(requested_path) or os.path.isdir(requested_path):
        return "Not Found", 404

    # The 'directory' for send_from_directory should be the direct parent of the file
    directory = os.path.dirname(requested_path)
    filename = os.path.basename(requested_path)
    
    return send_from_directory(directory, filename, as_attachment=True)


@app.route('/clear_server_list')
def clear_server_list():
    if 'username' not in session:
        return redirect(url_for('login'))
        
    user_part = session['username']
    input_folder = os.path.abspath(os.path.join(os.path.dirname(__file__), 'input'))
    file_path = os.path.join(input_folder, f'abc_{user_part}_serverlist.txt')
    
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            flash('Server list has been cleared.', 'success')
        except OSError as e:
            flash(f'Error clearing server list: {e.strerror}', 'error')
            
    return redirect(url_for('main'))


@app.route('/logout')
def logout():
    if 'username' in session:
        user_part = session['username']
        sec_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'sec'))
        
        # List of possible file suffixes
        file_suffixes = ['', '_cvm', '_ntnx']
        
        for suffix in file_suffixes:
            file_path = os.path.join(sec_dir, f'abc_{user_part}{suffix}.xml')
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                    flash(f'Successfully removed {os.path.basename(file_path)}.', 'success')
                except OSError as e:
                    flash(f'Error removing {os.path.basename(file_path)}: {e.strerror}', 'error')

    session.clear()
    flash('You have been logged out.', 'success')
    return redirect(url_for('login'))


if __name__ == '__main__':
    socketio.run(app, port=8084, debug=True)